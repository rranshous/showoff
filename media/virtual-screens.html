<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline' 'unsafe-eval';">
    <title>Virtual Screens</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--vscode-font-family);
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
            margin: 0;
            padding: 10px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .header {
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        h1 {
            color: var(--vscode-titleBar-activeForeground);
            font-size: 1.2em;
            margin-bottom: 3px;
        }
        
        .subtitle {
            color: var(--vscode-descriptionForeground);
            font-size: 0.8em;
        }
        
        .screens-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
        }
        
        .virtual-screen {
            background-color: var(--vscode-input-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 6px;
            padding: 10px;
            min-height: 150px;
            max-height: 300px;
            flex: 0 0 auto; /* Don't shrink */
            margin-bottom: 10px;
        }
        
        .screen-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--vscode-foreground);
            font-size: 0.9em;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--vscode-panel-border);
        }
        
        .screen-content {
            color: var(--vscode-foreground);
            font-size: 0.85em;
            padding: 10px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            max-height: 220px; /* Leave room for title */
        }
        
        .text-screen .screen-content {
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            padding: 12px;
            font-family: var(--vscode-editor-font-family);
        }
        
        /* Markdown styling */
        .screen-content h1, .screen-content h2, .screen-content h3 {
            color: var(--vscode-titleBar-activeForeground);
            margin: 8px 0 4px 0;
        }
        
        .screen-content h1 { font-size: 1.3em; }
        .screen-content h2 { font-size: 1.2em; }
        .screen-content h3 { font-size: 1.1em; }
        
        .screen-content code {
            background-color: var(--vscode-textCodeBlock-background);
            color: var(--vscode-textPreformat-foreground);
            padding: 2px 4px;
            border-radius: 2px;
            font-family: var(--vscode-editor-font-family);
        }
        
        .screen-content pre {
            background-color: var(--vscode-textCodeBlock-background);
            color: var(--vscode-textPreformat-foreground);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: var(--vscode-editor-font-family);
        }
        
        .screen-content ul, .screen-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .screen-content li {
            margin: 2px 0;
        }
        
        .screen-content strong {
            font-weight: 600;
            color: var(--vscode-foreground);
        }
        
        .screen-content em {
            font-style: italic;
            color: var(--vscode-descriptionForeground);
        }
        
        .screen-content a {
            color: var(--vscode-textLink-foreground);
            text-decoration: none;
        }
        
        .screen-content a:hover {
            text-decoration: underline;
        }
        
        .canvas-container {
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
            height: 220px; /* Match text screen max height */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }
        
        .canvas-screen canvas {
            background-color: #f8f8f8;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 2px;
            width: 100%;
            height: 100%;
            max-width: calc(100% - 10px);
            max-height: calc(100% - 10px);
        }
        
        .placeholder {
            text-align: center;
            color: var(--vscode-descriptionForeground);
            font-style: italic;
            padding: 40px 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üñ•Ô∏è Virtual Screens</h1>
        <div class="subtitle">Multi-screen workspace for AI interaction</div>
    </div>
    
    <div class="screens-container" id="screensContainer">
        <div class="placeholder" id="emptyPlaceholder">
            No virtual screens active<br>
            Use #virtual_screens or ask AI to create screens
        </div>
    </div>
    
    <script>
        console.log('Virtual Screens webview loaded successfully!');
        
        // Simple markdown parser for text screens
        function parseMarkdown(text) {
            if (!text) return '';
            
            return text
                // Headers
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                // Bold and italic
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                // Code blocks
                .replace(/```([^`]+)```/g, '<pre><code>$1</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Lists
                .replace(/^\s*\* (.+)$/gm, '<li>$1</li>')
                .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                .replace(/^\s*\d+\. (.+)$/gm, '<li>$1</li>')
                // Links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                // Line breaks
                .replace(/\n/g, '<br>');
        }
        

        


        // Sync screens from backend state
        function syncScreens(screens) {
            const container = document.getElementById('screensContainer');
            
            // Clear existing screens
            container.innerHTML = '';
            
            if (screens.length === 0) {
                const placeholder = document.createElement('div');
                placeholder.className = 'placeholder';
                placeholder.id = 'emptyPlaceholder';
                placeholder.innerHTML = 'No virtual screens active<br>Use #virtual_screens or ask AI to create screens';
                container.appendChild(placeholder);
            } else {
                screens.forEach(screen => {
                    const screenDiv = document.createElement('div');
                    screenDiv.className = `virtual-screen ${screen.type}-screen`;
                    screenDiv.id = `screen-${screen.id}`;
                    
                    if (screen.type === 'text') {
                        screenDiv.innerHTML = `
                            <div class="screen-title">${screen.title}</div>
                            <div class="screen-content" id="screen-${screen.id}-content"></div>
                        `;
                        
                        // Set content with markdown parsing
                        const contentElement = screenDiv.querySelector('.screen-content');
                        contentElement.innerHTML = parseMarkdown(screen.content);
                    } else { // canvas
                        screenDiv.innerHTML = `
                            <div class="screen-title">${screen.title}</div>
                            <div class="canvas-container">
                                <canvas id="screen-${screen.id}-canvas"></canvas>
                            </div>
                        `;
                        
                        // Execute canvas content with responsive sizing
                        setTimeout(() => {
                            const canvas = document.getElementById(`screen-${screen.id}-canvas`);
                            if (canvas) {
                                // Set canvas size to match container
                                const container = canvas.parentElement;
                                const rect = container.getBoundingClientRect();
                                canvas.width = Math.max(200, rect.width - 10); // Min 200px width
                                canvas.height = Math.max(150, rect.height - 10); // Min 150px height
                                
                                if (screen.content) {
                                    const ctx = canvas.getContext('2d');
                                    try {
                                        // Clear with light background
                                        ctx.fillStyle = '#f8f8f8';
                                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                                        
                                        // Execute the JavaScript function
                                        const userFunction = new Function('ctx', 'canvas', screen.content);
                                        userFunction(ctx, canvas);
                                    } catch (error) {
                                        console.error(`Error rendering canvas screen ${screen.id}:`, error);
                                        ctx.fillStyle = '#f8f8f8';
                                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                                        ctx.fillStyle = '#ff4444';
                                        ctx.font = '12px Arial';
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'top';
                                        ctx.fillText('Error: ' + error.message, 5, 5);
                                    }
                                } else {
                                    // Empty canvas with light background
                                    const ctx = canvas.getContext('2d');
                                    ctx.fillStyle = '#f8f8f8';
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                }
                            }
                        }, 10); // Small delay to ensure container is sized
                    }
                    
                    container.appendChild(screenDiv);
                });
            }
            
            console.log(`Synced ${screens.length} screens to UI`);
        }

        // Update or create a single screen without affecting others
        function updateSingleScreen(screen) {
            const container = document.getElementById('screensContainer');
            const placeholder = document.getElementById('emptyPlaceholder');
            
            // Remove placeholder if it exists
            if (placeholder) {
                placeholder.remove();
            }
            
            // Check if screen already exists
            const existingScreen = document.getElementById(`screen-${screen.id}`);
            if (existingScreen) {
                // Update existing screen
                updateExistingScreen(screen, existingScreen);
            } else {
                // Create new screen
                createNewScreen(screen, container);
            }
            
            console.log(`Updated single screen ${screen.id}`);
        }

        function updateExistingScreen(screen, screenDiv) {
            // Update title
            const titleElement = screenDiv.querySelector('.screen-title');
            if (titleElement) {
                titleElement.textContent = screen.title;
            }
            
            if (screen.type === 'text') {
                // Update text content with markdown parsing
                const contentElement = screenDiv.querySelector('.screen-content');
                if (contentElement) {
                    contentElement.innerHTML = parseMarkdown(screen.content);
                }
            } else { // canvas
                // For canvas, we need to re-execute the drawing code
                const canvas = screenDiv.querySelector('canvas');
                if (canvas && screen.content) {
                    const ctx = canvas.getContext('2d');
                    try {
                        // Clear with light background
                        ctx.fillStyle = '#f8f8f8';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Execute the JavaScript function
                        const userFunction = new Function('ctx', 'canvas', screen.content);
                        userFunction(ctx, canvas);
                    } catch (error) {
                        console.error(`Error updating canvas screen ${screen.id}:`, error);
                        ctx.fillStyle = '#f8f8f8';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#ff4444';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Error: ' + error.message, 5, 5);
                    }
                }
            }
        }

        function createNewScreen(screen, container) {
            const screenDiv = document.createElement('div');
            screenDiv.className = `virtual-screen ${screen.type}-screen`;
            screenDiv.id = `screen-${screen.id}`;
            
            if (screen.type === 'text') {
                screenDiv.innerHTML = `
                    <div class="screen-title">${screen.title}</div>
                    <div class="screen-content" id="screen-${screen.id}-content"></div>
                `;
                
                // Set content with markdown parsing
                const contentElement = screenDiv.querySelector('.screen-content');
                contentElement.innerHTML = parseMarkdown(screen.content);
            } else { // canvas
                screenDiv.innerHTML = `
                    <div class="screen-title">${screen.title}</div>
                    <div class="canvas-container">
                        <canvas id="screen-${screen.id}-canvas"></canvas>
                    </div>
                `;
                
                // Setup canvas with responsive sizing
                setTimeout(() => {
                    const canvas = document.getElementById(`screen-${screen.id}-canvas`);
                    if (canvas) {
                        const container = canvas.parentElement;
                        const rect = container.getBoundingClientRect();
                        canvas.width = Math.max(200, rect.width - 10);
                        canvas.height = Math.max(150, rect.height - 10);
                        
                        if (screen.content) {
                            const ctx = canvas.getContext('2d');
                            try {
                                ctx.fillStyle = '#f8f8f8';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                const userFunction = new Function('ctx', 'canvas', screen.content);
                                userFunction(ctx, canvas);
                            } catch (error) {
                                console.error(`Error creating canvas screen ${screen.id}:`, error);
                                ctx.fillStyle = '#f8f8f8';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ff4444';
                                ctx.font = '12px Arial';
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'top';
                                ctx.fillText('Error: ' + error.message, 5, 5);
                            }
                        } else {
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#f8f8f8';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                }, 10);
            }
            
            container.appendChild(screenDiv);
        }

        function removeSingleScreen(screenId) {
            const screenElement = document.getElementById(`screen-${screenId}`);
            if (screenElement) {
                screenElement.remove();
                console.log(`Removed screen ${screenId} from UI`);
                
                // Add placeholder if no screens left
                const container = document.getElementById('screensContainer');
                const remainingScreens = container.querySelectorAll('.virtual-screen');
                if (remainingScreens.length === 0) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'placeholder';
                    placeholder.id = 'emptyPlaceholder';
                    placeholder.innerHTML = 'No virtual screens active<br>Use #virtual_screens or ask AI to create screens';
                    container.appendChild(placeholder);
                }
            }
        }
        
        // Handle messages from the extension
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message from extension:', message);
            
            switch (message.command) {
                case 'syncScreens':
                    syncScreens(message.screens);
                    break;
                case 'updateSingleScreen':
                    updateSingleScreen(message.screen);
                    break;
                case 'removeSingleScreen':
                    removeSingleScreen(message.screenId);
                    break;
            }
        });
        


        // Send ready signal to extension
        if (typeof acquireVsCodeApi !== 'undefined') {
            const vscode = acquireVsCodeApi();
            vscode.postMessage({ command: 'webview-ready' });
        }
    </script>
</body>
</html>