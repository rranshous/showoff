{
  "name": "showoff",
  "displayName": "ShowOff - Visual Copilot Canvas",
  "description": "Gives Copilot a visual canvas to draw and collaborate",
  "version": "0.0.1",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": ["Other"],
  "activationEvents": [],
  "main": "./out/extension.js",
  "contributes": {
    "views": {
      "showoff-sidebar": [
        {
          "type": "webview",
          "id": "showoff.canvasView",
          "name": "Canvas",
          "icon": "$(symbol-color)"
        }
      ],
      "virtualscreens-sidebar": [
        {
          "type": "webview",
          "id": "virtualscreens.screensView",
          "name": "Virtual Screens",
          "icon": "$(device-desktop)"
        }
      ]
    },
    "viewsContainers": {
      "activitybar": [
        {
          "id": "showoff-sidebar",
          "title": "ShowOff Canvas",
          "icon": "$(symbol-color)"
        },
        {
          "id": "virtualscreens-sidebar",
          "title": "Virtual Screens",
          "icon": "$(device-desktop)"
        }
      ]
    },
    "commands": [
      {
        "command": "showoff.showCanvas",
        "title": "Show Canvas"
      }
    ],
    "languageModelTools": [
      {
        "name": "draw_canvas",
        "displayName": "ShowOff Canvas Drawing Tool",
        "modelDescription": "Draw on the ShowOff visual canvas using JavaScript with powerful animation libraries. The canvas fills the entire panel and automatically resizes. Takes JavaScript code as a string (function body only, not a named function declaration). Available tools: HTML5 Canvas API (ctx.fillRect, ctx.arc, etc.), GSAP animation library (gsap.to, gsap.timeline, etc.), and PIXI.js WebGL renderer (PIXI.Application, PIXI.Sprite, etc.). Canvas context available as 'ctx', canvas object as 'canvas'. For GSAP animations: Use onUpdate callbacks rather than requestAnimationFrame loops. Example: gsap.to(obj, {x: 100, onUpdate: renderFunction}) or timeline with onUpdate. This leverages GSAP's internal ticker and optimization. Recommended: GSAP + PIXI hybrid - GSAP animates PIXI objects, PIXI renders via WebGL for best performance and animation quality.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "draw_canvas",
        "icon": "$(symbol-color)",
        "userDescription": "Draw visualizations on the ShowOff canvas using JavaScript code",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jsFunction": {
              "type": "string",
              "description": "JavaScript code to execute in the canvas context. Provide ONLY the function body code, NOT a named function declaration. Available: HTML5 Canvas API (ctx, canvas), GSAP animation library (gsap), and PIXI.js WebGL renderer (PIXI). For GSAP animations: Use onUpdate callbacks rather than requestAnimationFrame loops. Example: gsap.to(obj, {x: 100, onUpdate: renderFunction}) or timeline with onUpdate. Recommended: GSAP + PIXI hybrid - GSAP animates PIXI objects, PIXI renders via WebGL. Best performance and animation quality. Examples: Canvas: 'ctx.fillStyle=\"red\"; ctx.fillRect(10,10,100,50);' | GSAP: 'gsap.to(obj, {x:100, onUpdate:()=>redraw()});' | PIXI: 'const app=new PIXI.Application({view:canvas});'"
            }
          },
          "required": ["jsFunction"]
        }
      },
      {
        "name": "manage_virtual_screens",
        "displayName": "Virtual Screens Management Tool",
        "modelDescription": "Manage multiple virtual screens for displaying text content or drawing visualizations. Each screen has a unique ID (1, 2, 3, etc.) and supports two types: 'text' screens for displaying information, lists, code snippets, or any textual data, and 'canvas' screens for creating drawings, charts, diagrams using JavaScript and HTML5 Canvas API. For canvas animations, use requestAnimationFrame() in proper animation loops. Screens can be created, updated, read, or cleared independently and are persistent until modified. Use this to organize information across multiple screens for better user experience.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "virtual_screens",
        "icon": "$(device-desktop)",
        "userDescription": "Manage multiple virtual screens for text content and canvas drawings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "enum": ["create", "update", "clear", "read"],
              "description": "Action to perform: 'create' to make a new screen, 'update' to modify existing screen content, 'clear' to remove a screen, 'read' to get current screen content"
            },
            "screenId": {
              "type": "number",
              "description": "Numeric ID of the screen to manage (1, 2, 3, etc.). Use consistent IDs to reference the same screen across operations."
            },
            "screenType": {
              "type": "string",
              "enum": ["text", "canvas"],
              "description": "Type of screen: 'text' for text content or 'canvas' for drawing. Required when creating new screens."
            },
            "content": {
              "type": "string",
              "description": "For text screens: text content to display with markdown formatting support (headers, bold, italic, code, lists, links). For canvas screens: JavaScript code to execute in canvas context - provide ONLY function body code (e.g., 'ctx.fillStyle = \"blue\"; ctx.fillRect(10, 10, 100, 50);'). For animations, use requestAnimationFrame loops: 'function animate() { /* drawing code */ requestAnimationFrame(animate); } animate();'. The canvas context 'ctx' and canvas object 'canvas' are automatically available. Leave empty or omit for 'clear' action."
            },
            "title": {
              "type": "string",
              "description": "Optional title for the screen when creating new screens. If not provided, defaults to 'Screen #X'"
            }
          },
          "required": ["action", "screenId"]
        }
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/vscode": "^1.90.0",
    "@types/node": "16.x",
    "typescript": "^4.9.4"
  }
}